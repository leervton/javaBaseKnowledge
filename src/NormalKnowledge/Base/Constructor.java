package NormalKnowledge.Base;

/**
 * 实例对象在堆内存中创建时：构造器并不是创建实例对象
 * 构造器作用：
 *      用于创建对象并初始化对象属性的方法，叫“构造方法”，也叫“构造器”；构造器在类中定义【构造器唯一的作用就是给对象属性初始化/初始化对象属性】。
 *
 *          1.构造器的名称必须与类名同名，包括大小写。
 *
 *          2.构造器没有返回值，但也不能写void，也不能写return。
 *
 *          3.构造器的参数：一般是初始化对象的前提条件。
 *
 *          4.用new调用！且对象一建立，构造器就运行且仅运行一次。一般方法可被调用多次。
 *
 *          5.类一定有构造器！这是真的，不需要质疑！
 *
 *          6.如果类没有声明（定义）任何的构造器，Java编译器会自动插入默认构造器！
 *
 *          7.默认构造是无参数，方法体是空的构造器，且默认构造器的访问权限随着所属类的访问权限变化而变化。
 *            如，若类被public修饰，则默认构造器也带public修饰符。
 *
 *          8.默认构造器是看不到的，一旦自己写上构造器则默认构造器就没有了，自己写的叫自定义构造器，
 *            即便自己写的是空参数的构造器，也是自定义构造器，而不是默认构造器。
 *
 *          9.如果类声明了构造器，Java编译器将不再提供默认构造器。若没手动写出无参构造器，但却调用了无参构造器，将会报错！
 *
 *          10.构造器是可以重载的，重载的目的是为了使用方便，重载规则与方法重载规则相同。
 *
 *          11.构造器是不能继承的！虽说是叫构造方法，但实际上它不是常说的一般方法。
 *
 *          12.子类继承父类，那么子类型构造器默认调用父类型的无参数构造器。（正是因为构造器不能被继承，所以子类中才需要重新调用父类构造器，也可以重写）
 *
 *          13.子类构造器一定要调用父类构造器，如果父类没有无参数构造器，则必须使用super(有参数的)，来调用父类有参的构造器。
 *             那么，为什么子类一定要访问父类的构造器？因为父类中的数据子类可以直接获取。
 *             所以子类对象在建立时，需要先查看父类是如何对这些数据进行初始化的，所以子类在对象初始化时，要先访问一下父类中的构造器。
 *             总之，子类中至少会有一个构造器会访问父类中的构造器，且子类中每一个构造函数内的第一行都有一句隐式super()。
 *
 *         注意事项：super()、super．和 this()、this．
 *          this：在运行期间，哪个对象在调用this所在的方法，this就代表哪个对象，隐含绑定到当前“这个对象”。
 *          super()：调用父类无参构造器，一定在子类构造器第一行使用！如果没有则是默认存在super()的！这是Java默认添加的super()。
 *          super．是访问父类对象，父类对象的引用，与this．用法一致
 *          this()：调用本类的其他构造器，按照参数调用构造器，必须在构造器中使用，必须在第一行使用，this() 与 super() 互斥，不能同时存在
 *          this．是访问当前对象，本类对象的引用，在能区别实例变量和局部变量时，this可省略，否则一定不能省！
 *          如果子父类中出现非私有的同名成员变量时，子类要访问本类中的变量用this． ；子类要访问父类中的同名变量用super．
 *           eg：默认构造器
 */

public class Constructor {
    public static void main(String[] args) {


        Foo foo = new Foo();//调用了javac自动添加的默认构造器！

        //Koo koo = new Koo();//编译错误，没有Koo()构造器

        Koo koo = new Koo(8);
    }
}

class Foo { } //Foo有构造器，有无参数的默认构造器！

class Koo {
    public Koo(int a) {  //声明了有参数构造器
        System.out.println("Call Koo(int)");
    }
}

