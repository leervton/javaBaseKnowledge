package JavaBasicKnowledge.Thread.ThreadSafe;

/**
 * java中有三大变量
 * 1.成员变量：
 *      1.实例变量：在堆中
 *      2.静态变量：在方法区
 * 2.局部变量：在栈中
 *  以上三大变量中：
 *      局部变量永远都不会存在线程安全问题
 *      因为局部变量不共享（一个线程一个栈）
 *      局部变量在栈中，所以局部变量永远都不会共享
 *
 *      实例变量在堆中，静态变量在方法区中，它们都是只有1个
 *      所以他们都是多线程共享，所以存在线程安全问题
 *
 * 3.synchronized有三种写法：
 *      第一种：同步代码块
 *          灵活
 *          synchronized（线程共享对象）{
 *              同步代码块;
 *          }
 *      第二种：在实例方法上使用synchronized
 *          表示共享对象一定是this
 *          并且同步代码块是整个方法体
 *      第三种：在静态方法上使用synchronized
 *          表示找类锁
 *          类锁永远只有一把
 *          就算创建了100个对象，也只有一把类锁
 *
 *          对象锁：一个对象一把锁，100个对象100把锁
 *          类锁：100个对象，只有一把类锁
 *
 *4.synchronized的作用是什么？
 *      带有synchronized的线程会被锁住，只有根据synchronized后面的小括号去寻找对象锁池里的对象锁才会有执行权，
 *      找不到对象锁就没有执行权，只能在阻塞状态等待，直到其他线程执行完，释放掉对象的对象锁
 *      该线程获取到这个对象的对象锁
 *
 *      如果多个synchronized线程共享同一个对象，但对象的对象锁却有一个，那获得对象锁的线程如果不释放对象锁，其他线程便无权执行
 *      直到获得对象锁的线程释放对象锁，其他线程才可以去锁池寻找对象锁，这样所有线程便依次执行了
 */
public class ThreadSafeBase01 {
}
