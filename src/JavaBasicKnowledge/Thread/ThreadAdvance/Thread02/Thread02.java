package JavaBasicKnowledge.Thread.ThreadAdvance.Thread02;

/**
 * https://blog.csdn.net/xingjing1226/article/details/81977129
 * https://www.cnblogs.com/thinfog/p/11250913.html
 * https://blog.csdn.net/xingjing1226/article/details/81977129
 *
 * java语言中实现线程有两种方式
 * java支持多线程机制，并且java已经将多线程实现了，我们只需要继承就行了
 *      哪两种方式？
 *          第一种：编写一个类，直接继承java.lang.Thread,重写run方法
 *                  怎么创建线程对象？new就行了
 *                  怎么启动线程？调用线程的start方法
 *
 *  注意：方法体当中的代码，永远都是自上而下的顺序依次逐行执行的
 *
 *  以下程序的输出结果有这样的特点：
 *      有先有后
 *      有多有少
 *      这是咋回事？
 */
public class Thread02 {
    public static void main(String[] args) {
        //这里是main方法，这里的代码属于主线程，在主栈中运行
        //新建一个分支线程对象
        MyThread myThread = new MyThread();
        //myThread.run();//该方法只是普通方法调用，不是线程并发方法
                        //调用这个方法不会启动线程，也不会分配新的分支栈空间，等于在main方法所在的栈内存中运行这个方法，无法并发，属于单线程
                        //而且没有分配新的栈空间，也就不存在多线程的说法，也不会并发

        //启动线程
        //start()方法的作用是：启动一个分支线程，在jvm中开辟一个新的栈空间，这段代码任务完成之后，瞬间就结束了
        //这段代码的任务只是为了开启一个新的栈空间，只要新的栈空间开出来，start()方法就结束了，线程就启动成功了
        //启动成功的线程会自动调用run()方法，并且run()方法在分支栈的底部（压栈）
        //run()方法在分支栈的栈底部，main()方法在主栈的栈底部，run和main是平级的
        //==========================就绪状态==================================
        /*
            调用start()方法使线程对象进入就绪状态，又叫做可运行状态，表示当前线程具有抢夺cpu时间片的权力（cpu时间片就是执行权）
            当一个线程抢夺到cpu时间片之后，就开始执行run()方法，run()方法的开始执行标志着线程进入运行状态
         */
        //==========================运行状态==================================
        /*
            run()方法的执行标志着这个线程进入运行状态，当之前占有的cpu时间片用完之后，会重新回到就绪状态继续抢夺cpu时间片，当再次
            抢到cpu时间片之后，会重新进入run()方法接着上一次的代码继续往下执行
         */
        //==========================阻塞状态(暂时丧失抢夺时间片的资格)==================================
        /*
           当一个线程被插队、礼让别的线程或者休眠时就会进入到阻塞状态，阻塞状态解除后回到就绪状态，等待CPU调度执行
           或者
           一个正在执行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入输出操作时，将让出 CPU 并暂时中止
           自己的执行，进入堵塞状态。在可执行状态下，如果调用 sleep()、 suspend()、 wait()等方法，线程都将进入堵塞状态。
           堵塞时，线程不能进入排队队列，只有当引起堵塞的原因被消除后，线程转入就绪状态。重新到就绪队列中排队等待，
           这时被CPU调度选中后会从原来停止的位置开始继续执行。
           记住：阻塞被消除后是回到就绪状态，不是运行状态。
           当一个线程遇到阻塞事件，例如接受用户键盘输入，或者sleep方法等，此时线程会进入阻塞状态，阻塞状态的线程会放弃之前所占有的cpu时间片
           当阻塞解除之后会进入就绪状态继续抢夺cpu时间片，因为之前的cpu时间片已经释放掉了，没了，需要重新抢夺
         */
        //==========================死亡状态==================================
        /*
            run()结束标志着线程进入死亡状态
         */
        myThread.start();

        //这里的代码还是运行在主线程中
        for (int i=0;i<1000;i++){
            System.out.println("主线程-----》"+i);
        }

    }
}
class MyThread extends Thread{
    //线程的run方法相当于主线程的main方法
    @Override
    public void run() {
        //编写程序，这段程序运行在分支程序中（分支栈）
        for (int i=0;i<1000;i++){
            System.out.println("分支线程-----》"+i);
        }
    }
}
