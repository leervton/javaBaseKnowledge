package JavaBasicKnowledge.sort;

public class ArrayUtil{
    public static void main(String[] args) {

    }
    /**
     * 1.数组工具类：自己写的，不是sun公司的
     *
     * 2.关于查找算法中的：二分法查找（折半查找）
     *      10（下标0），11，12，13，14，15，16，17，18，19，20（下标10）
     *      通过二分法查找，找出18这个元素的下标：
     *          （0+10）/2 ------>中间元素的下标：5
     *      拿着这个中间元素和目标要查找的元素进行比对：
     *          中间元素是：arr[5]------->15
     *          15<18(被查找的元素在右边)
     *          被查找的元素18在中间元素15的右边
     *          所以开始元素的下标从0变成5+1
     *
     *      再重新计算下一个中间元素的下标
     *          开始下标：5+1
     *          结束下标：10
     *          中间下标：（6+10）/2----->8
     *          arr[8]=18
     *          找到的下标为8的中间元素正好是18，表示找到该数据了，下标为8
     *
     *      二分法查找的终止条件：一直折半，直到中间的那个元素恰好是被查找的元素
     *
     * 3.二分法查找是基于排序的基础之上（没有排序的数据是无法查找的）
     */
    public static int binarySearch(int[] arr,int dest){

        //开始下标
        int begin =0;
        //结束下标
        int end = arr.length-1;

        //开始元素的下标只要在结束元素下标的左边，就有机会一直循环
        /**
         * 这个循环终止条件并不是终止dest ==arr[mid]的情况，
         * 而是对dest！=arr[mid]这个无限循环的终止，当然采用递归算法逻辑上更好懂，但效率明显比较低
         * 有人说过“所有的递归算法都可以转化成循环”，所以我们这里用极限思想考虑递归的终止条件，即dest == arr[mid]来帮助我们把递归变成循环
         * 因为不采用递归，而采用循环的话，dest ==arr[mid]会自动终止循环，而dest ！=arr[mid]却不会，但是我们仔细思考一下
         * 如果dest ！=arr[mid]的情况下，arr[begin]和arr[end]分别位于查找结果的两边，二分法却会让他两靠的越来越近，
         * 直至arr[begin]和arr[end]的中间元素等于dest就终止循环了
         * 最极端的情况或许就是arr[begin]，arr[mid]和arr[end]跑到同一个点，这时，他们三个必然会出结果
         *
         * --------------------------------------------------------
         * 所以递归转循环，我们应该考虑递归的终止条件作为循环条件的突破口
         * 也可以这么说，递归的终止条件和循环的终止条件是一摸一样的
         */
        while(begin <= end){
            //中间下标
            int mid =(begin + end)/2;


            if (dest < arr[mid]) {
                //数据再中间元素的右边
                end = mid - 1;
            } else if (dest > arr[mid]) {
                //数据在中间元素的左边
                begin = mid + 1;
            } else if (dest == arr[mid]) {
                return mid;
            }
        }
        return -1;
    }
}
